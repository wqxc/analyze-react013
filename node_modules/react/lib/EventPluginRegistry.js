/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginRegistry
 * @typechecks static-only
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 * Injectable ordering of event plugins.
 * 存储事件插件模块的执行顺序。（哪些插件先执行，哪些后执行）
 */
var EventPluginOrder = null;
/*
 EventPluginOrder的值为：
[ 'ResponderEventPlugin',
  'SimpleEventPlugin',
  'TapEventPlugin',
  'EnterLeaveEventPlugin',
  'ChangeEventPlugin',
  'SelectEventPlugin',
  'BeforeInputEventPlugin']
*/ 



/**
 * Injectable mapping from names to event plugin modules.
 * 以键值对的形式存储加载的事件插件模块
 */
var namesToPlugins = {};
// namesToPlugins的值：
// {  
//   SimpleEventPlugin: SimpleEventPlugin,
//   EnterLeaveEventPlugin: EnterLeaveEventPlugin,
//   ChangeEventPlugin: ChangeEventPlugin,
//   SelectEventPlugin: SelectEventPlugin,
//   BeforeInputEventPlugin: BeforeInputEventPlugin
// }

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
<<<<<<< HEAD
 * 使用注入的plugins和plugin ordering 来重新计算 plugin list
 * 简单来说就是根据 EventPluginOrder和namesToPlugins来计算出新的的插件数组（核心是顺序）
=======
 *重新计算插件列表，使用注入的插件以及其顺序
 校验事件插件模块，设定事件插件模块的执行顺序，完成注册。
>>>>>>> feat: EventPlugin系列的内容
 * @private
 */
function recomputePluginOrdering() {
  if (!EventPluginOrder) {
    // Wait until an `EventPluginOrder` is injected.
    // 等到有插件顺序存在的时候执行。
    return;
  }
  for (var pluginName in namesToPlugins) {
    // 遍历namesToPlugins
    var PluginModule = namesToPlugins[pluginName];
  
    var pluginIndex = EventPluginOrder.indexOf(pluginName);
    // 得到当前pluginName 在EventPluginOrder中的位置（EventPluginOrder中定义了插件加载的先后顺序，这是必须的否则会有难以预料的错误。）
    // namesToPlugins是EventPluginOrder的子集，所以在加载之前我们需要确认namesToPlugins内事件插件的顺序，放在plugin数组内
    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
    
    if (EventPluginRegistry.plugins[pluginIndex]) {
      continue;
    }
    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
    var publishedEvents = PluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
      /*
      eventName ：abort,blur,foucs。。。。
      publishedEvents[eventName]===
      {
        phasedRegistrationNames: {
          bubbled: keyOf({ onAbort: true }),
          captured: keyOf({ onAbortCapture: true })
        }
      }
      */ 
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 * 发布事件，以便可以通过提供的插件来分派该事件。
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {

  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
   /*
      eg: 
      PluginModule: SimpleEventPlugin
      eventName ：abort,blur,foucs。。。。
      dispatchConfig===
      {
        phasedRegistrationNames: {
          bubbled: keyOf({ onAbort: true }),
          captured: keyOf({ onAbortCapture: true })
        }
      }

      eventNameDispatchConfigs = {
        abort:{
          {
            phasedRegistrationNames: {
              bubbled: keyOf({ onAbort: true }),
              captured: keyOf({ onAbortCapture: true })
            }
          }
        }
      }
      */ 
  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      /*
        eg: SimpleEventPlugin
        phraseName 只有两个值 bubbled 和 captured
      */ 
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        /*
          eg：SimpleEventPlugin
          phasedRegistrationName 是 onAbort  onAbortCapture
          这是React合成的事件名称，原生的abort事件，在冒泡阶段是 onAbort，捕获阶段是onAbortCapture 
        */ 
        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
        // 比如 publishRegistrationName('onAbort', 'SimpleEventPlugin', 'abort');
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, PluginModule, eventName) {
  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
  // 将注册的事件比如 onAbort 需要使用事件插件 进行映射并放在registrationNameModules对象中。
  // registrationNameModules对象类似于
  /*
    {
      onAbort:SimpleEventPlugin,
      onAbortCapture:SimpleEventPlugin
    }
  */ 
  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
  /*
    注册事件的依赖

    比如
    registrationNameDependencies 对象为
    浏览器的原生事件类型，与在Document上注册的事件名称的映射
    {
      onAbort:['topAbort']
    }
  */ 
}

/**
 * Registers plugins so that they can extract and dispatch events.
 * 注册插件，以便他们可以提取和调度事件。
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry = {

  /**
   * Ordered list of injected plugins.
   */
  plugins: [],
  /*
    以EventPluginOrder内的事件插件的顺序为标准，namesToPlugins为需要注入的事件插件数组。
    我们以EventPluginOrder的每一项存在的位置，来讲namesToPlugins中的每一项拿出来放在plugins中。
  */ 

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},
  /*
  其实是 SimpleEventPlugin 的 eventTypes
  eventNameDispatchConfigs:
  {
        abort:
        {
          {
            phasedRegistrationNames: {
              bubbled: keyOf({ onAbort: true }),
              captured: keyOf({ onAbortCapture: true })
            }
          }
        }
      ....

    }
  */ 

  /**
   * Mapping from registration name to plugin module
   * 注册事件的名称与对应的处理插件的映射。
   */
  registrationNameModules: {},
  // 将注册的事件比如 onAbort 需要使用事件插件（插件用来生成合成事件） 进行映射并放在registrationNameModules对象中。
  // registrationNameModules对象类似于
  /*
    {
      onAbort:SimpleEventPlugin,
      onAbortCapture:SimpleEventPlugin
    }
  */ 

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},
  /*
    浏览器的原生事件类型，与在Document上注册的事件名称的映射

    比如
    registrationNameDependencies 对象为
    {
      onAbort:['topAbort']
    }
  */ 

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function (InjectedEventPluginOrder) {
    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
    // Clone the ordering so it cannot be dynamically mutated.
    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * 注入的插件被 EventPluginHub使用。注入的插件的名字必须采用 injectEventPluginOrder中注入的顺序
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *  插件可以作为页面初始化的一部分注入，或者是即用即注入
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function (injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var PluginModule = injectedNamesToPlugins[pluginName];
     
      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
        namesToPlugins[pluginName] = PluginModule;
        isOrderingDirty = true;
      }
    }
    // pluginName = [SimpleEventPlugin,
    //   EnterLeaveEventPlugin,
    //   ChangeEventPlugin,
    //   SelectEventPlugin,
    //   BeforeInputEventPlugin
    // ]
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *为支持的事件查找插件
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function (event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
    }
    for (var phase in dispatchConfig.phasedRegistrationNames) {
      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
        continue;
      }
      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
      if (PluginModule) {
        return PluginModule;
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function () {
    EventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }
  }

};

module.exports = EventPluginRegistry;