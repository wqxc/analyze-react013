/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEventListener
 * @typechecks static-only
 */

'use strict';

var EventListener = require('fbjs/lib/EventListener');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var PooledClass = require('./PooledClass');
var ReactInstanceHandles = require('./ReactInstanceHandles');
var ReactMount = require('./ReactMount');
var ReactUpdates = require('./ReactUpdates');

var assign = require('./Object.assign');
var getEventTarget = require('./getEventTarget');
var getUnboundedScrollPosition = require('fbjs/lib/getUnboundedScrollPosition');

var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

/**
 * Finds the parent React component of `node`.
 *
 * @param {*} node
 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
 *                           is not nested.
 */
function findParent(node) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  // getID会从自己维护的对象列表（一个缓存）中找到当前node的id。
  var nodeID = ReactMount.getID(node);
  // getReactRootIDFromNodeID会根据node的自身ID，找到包裹他的React根元素的ID。
  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
  // 根据rootid找到React根组件外部的DOM元素，单页面应用，一般是 <div id="app"></div>
  var container = ReactMount.findReactContainerForID(rootID);
  // 根据container找到其FirstReactDOM.container是在所有的React组件之外的，所以此时的parent是null.
  var parent = ReactMount.getFirstReactDOM(container);
  return parent;
}

// Used to store ancestor hierarchy in top level callback
function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
  this.topLevelType = topLevelType;
  this.nativeEvent = nativeEvent;
  this.ancestors = [];
}
assign(TopLevelCallbackBookKeeping.prototype, {
  destructor: function () {
    this.topLevelType = null;
    this.nativeEvent = null;
    this.ancestors.length = 0;
  }
});
PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

function handleTopLevelImpl(bookKeeping) {
  // TODO: Re-enable event.path handling
  //
  // if (bookKeeping.nativeEvent.path && bookKeeping.nativeEvent.path.length > 1) {
  //   // New browsers have a path attribute on native events
  //   handleTopLevelWithPath(bookKeeping);
  // } else {
  //   // Legacy browsers don't have a path attribute on native events
  //   handleTopLevelWithoutPath(bookKeeping);
  // }

  void handleTopLevelWithPath; // temporarily unused
  handleTopLevelWithoutPath(bookKeeping);
}

// Legacy browsers don't have a path attribute on native events
// path属性是现代浏览器的事件的一个属性，该属性包含了当前触发元素冒泡的全过程。 chrome有，Safari么有该属性。
// 现代的浏览器提供了一个方法来返回当前事件的冒泡全过程DOM。 event.composedPath()
function handleTopLevelWithoutPath(bookKeeping) {
  // getEventTarget方法作用是根据源事件，找到触发源事件的DOM元素。
  // getFirstReactDOM得到距离触发事件的源对象最近的dom，一般是其自身，也考虑到触发事件的可能是text_node
  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;
  // topLevelTarget是触发事件的当前元素，这里的方法就是为了找到最近的一个DOM元素，


  // Loop through the hierarchy, in case there's any nested components.
  // 遍历层次结构，防止任何嵌套组件存在
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  // 在调用之前先存储祖先层次结构，因为事件处理函数会改变DOM结构。
  var ancestor = topLevelTarget;
  while (ancestor) {
    bookKeeping.ancestors.push(ancestor);
    ancestor = findParent(ancestor);
  }
  // ancestors 里一般是存了当前触发事件的元素

  

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    topLevelTarget = bookKeeping.ancestors[i];
    // topLevelTarget 是事件触发的源元素。
    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
    // topLevelTargetID 源元素的id

    ReactEventListener._handleTopLevel(
        bookKeeping.topLevelType, 
        topLevelTarget, 
        topLevelTargetID, 
        bookKeeping.nativeEvent, 
        getEventTarget(bookKeeping.nativeEvent)
    );

    /*
      ReactEventListener._handleTopLevel方法最终是调用了
      ReactEventEmitterMixin.handleTopLevel方法。
      而ReactEventEmitterMixin.handleTopLevel 方法是调用 EventPluginHub.extractEvents 方法生成合成事件，
      而后将合成事件放入事件队列里执行。

      而关于生成合成事件:
      EventPluginHub.extractEvents方法会选择不同的事件插件进行处理生成合成事件。
      比如调用simpleEventPlugin的extractEvents方法，而
      simpleEventPlugin的extractEvents方法的核心是调用了
      EventPropagators.accumulateTwoPhaseDispatches 方法。
      而 EventPropagators.accumulateTwoPhaseDispatches 方法则是调用了
      该模块下的 accumulateTwoPhaseDispatches。
      而 accumulateTwoPhaseDispatches方法则是调用了
      EventPluginHub.injection.getInstanceHandle().traverseTwoPhase()方法。
      实则是调用了 ReactInstanceHandles模块的 traverseTwoPhase()方法，
      traverseTwoPhase方法则是根据给的事件触发的id来执行两个方法。
      ReactInstanceHandles模块的下的
      traverseParentPath('', targetID, cb, arg, true, false);
      该函数的主要作用是计算从React跟组件到触发事件的这个组件之间的所经过的全部React组件
      而后主要是调用了一个方法。EventPropagators模块下的 accumulateDirectionalDispatches 方法。
      而EventPropagators.accumulateDirectionalDispatches方法的主要作用是 根据捕获事件流所经过的全部的
      React组件的id找到对应事件的侦听器。主要是从listenerBank中取出来，而后放入源事件的属性中。
      如下：
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);

      traverseParentPath(targetID, '', cb, arg, false, true);
      这个方法只是冒泡流的机制来找到所有的侦听器。

      最后将合成事件放入队列中，而后一个个的去执行这些事件。
      用到的方法是。
      EventPluginHub.enqueueEvents(events);
      EventPluginHub.processEventQueue(false);
    */ 
  }
}

// New browsers have a path attribute on native events
function handleTopLevelWithPath(bookKeeping) {
  var path = bookKeeping.nativeEvent.path;
  var currentNativeTarget = path[0];
  var eventsFired = 0;
  for (var i = 0; i < path.length; i++) {
    var currentPathElement = path[i];
    if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {
      currentNativeTarget = path[i + 1];
    }
    // TODO: slow
    var reactParent = ReactMount.getFirstReactDOM(currentPathElement);
    if (reactParent === currentPathElement) {
      var currentPathElementID = ReactMount.getID(currentPathElement);
      var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);
      bookKeeping.ancestors.push(currentPathElement);

      var topLevelTargetID = ReactMount.getID(currentPathElement) || '';
      eventsFired++;
      ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);

      // Jump to the root of this React render tree
      while (currentPathElementID !== newRootID) {
        i++;
        currentPathElement = path[i];
        currentPathElementID = ReactMount.getID(currentPathElement);
      }
    }
  }
  if (eventsFired === 0) {
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}

var ReactEventListener = {
  _enabled: true,
  _handleTopLevel: null,

  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

  setHandleTopLevel: function (handleTopLevel) {
    ReactEventListener._handleTopLevel = handleTopLevel;
  },

  setEnabled: function (enabled) {
    ReactEventListener._enabled = !!enabled;
  },

  isEnabled: function () {
    return ReactEventListener._enabled;
  },

  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */

  //  @param topLevelType：topAbort,topClick等
  //  @param handlerBaseName：abort,click等
  //  @param handle：一个document

  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return null;
    }
    /*
      注意：
      listen方法主要是调用了addEventListener方法。而addEventListener方法接受三个参数。
      //  @param eventType：就是click，abort等。
      //  @param callback ：就是事件触发的时候的回调函数。
      //  @param Boolean值： 表示在什么时候触发，冒泡阶段，还是捕获阶段默认是false，冒泡阶段。
      而到了这里，我们没有拿到一个回调函数callback，你看给的三个参数是：topLevelType, handlerBaseName, handle

      这里React给了一个函数 ReactEventListener.dispatchEvent.bind(null, topLevelType)来做回调函数。
      这个回调函数，和我们绑定在页面上的回调函数不是一回事。
      我们在页面上绑定的回调函数，最终是存储在了EventPluginHub的listenerBank中了。
    */ 
    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return null;
    }
    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  monitorScrollValue: function (refresh) {
    var callback = scrollValueMonitor.bind(null, refresh);
    EventListener.listen(window, 'scroll', callback);
  },

  /*
    这里React为每一我们注册的个事件比如onClick，提供了一个方法，来代替了我们写的回调函数。
  */ 
  dispatchEvent: function (topLevelType, nativeEvent) {
    if (!ReactEventListener._enabled) {
      return;
    }
    // 创建了一个对象，这个对象里包含了一个nativeEvent（源事件对象。）一个当前的top事件。比如topAbort。
    // 一个数组 ancestor。用来存储触发元素的祖先层次结构。
    // 在初始条件下。ancestor是空数组，而且nativeEvent是没有赋值的。
    // 这个对象的作用就是用来存储的。为每一次的事件触发，存储一些内容。
    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);

    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      /*
        这里真正重要的是 ReactUpdates.batchedUpdates方法。

      */ 


      /*
        ReactUpdates.batchedUpdates是 使用ReactDefaultBatchingStrategy模块的批处理策略。
        batchedUpdates
      */

      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
      // 这里 ReactUpdates.batchedUpdates 是采用React的批处理策略，来处理参数。
      // 主要是使用使用bookKeeping作为 handleTopLevelImpl 的参数来调用该方法
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  }
};

module.exports = ReactEventListener;