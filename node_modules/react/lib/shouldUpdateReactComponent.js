/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule shouldUpdateReactComponent
 * @typechecks static-only
 */

'use strict';

/**
 * Given a `prevElement` and `nextElement`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are elements. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevElement
 * @param {?object} nextElement
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */

//  prevElement是之前已经存在的 组件信息，nextElement是要替换prevElement的组件。
//  该函数的作用是计算一下是不是要更新。

/*

  prevElement 和 nextElement 一样的话，就返回true。
  比如 prevElement和 nextElement 都为null或者是都为false的时候返回true
  prevElement和 nextElement 都为 string 类型 或者是都为 number 类型的时候返回true
  prevElement和 nextElement 都为Object类型，切两者的key相等。则返回true、

  猜测：返回true的话就说明 要替换 prevElement 的 nextElement 与 prevElement类型一致，可以选择对其进行更新
  操作。
  而如果 返回了false 说明，要替换的东西nextElement和 prevElement不是有一个东西，不如完全的卸载 prevElement，
  而后直接将 nextElement挂载上去来的性能高。
*/ 
function shouldUpdateReactComponent(prevElement, nextElement) {
  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;
  if (prevEmpty || nextEmpty) {
    return prevEmpty === nextEmpty;
  }

  var prevType = typeof prevElement;
  var nextType = typeof nextElement;
  if (prevType === 'string' || prevType === 'number') {
    return nextType === 'string' || nextType === 'number';
  } else {
    return nextType === 'object' && 
    prevElement.type === nextElement.type 
    && prevElement.key === nextElement.key;
  }
  return false;
}

module.exports = shouldUpdateReactComponent;